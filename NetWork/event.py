"""
Events are used to enable taks to signal each other that an event has
occured. For example, a task that needs some data generated by another task
can wait for an event signaled by that task. The waiter process calls the :py:meth:`wait <NWEvent.wait>`
method of the event and is put to sleep. When another task call the :py:meth:`set <NWEvent.set>` method
of the same event the first task is waken up and continues it's work

::

    #Usage example
    #Prints "Event has been raised" after 5 seconds
    import time
    from NetWork import Workgroup, Event
    
    def waiter(eventToWait):
        eventToWait.wait()
        print("Event has been raised")
    
    with Workgroup(addresses) as w:
        myEvent=Event(w)
        myTask=w.submit(target=waiter, args=(myEvent,))
        sleep(5)
        myEvent.set()
        sleep(1)    #Dont kill workgroup until the message is sent to worker

For more info about events see `Python documentation page
<http://docs.python.org/3.3/library/threading.html#event-objects>`_
"""
from multiprocessing import Event

from .networking import sendRequest
from .commcodes import CMD_WORKER_DIED
from .cntcodes import CNT_WORKERS
from .request import Request
from .worker import DeadWorkerError


CMD_SET_EVENT = b"EVS"
CMD_REGISTER_EVENT = b"EVR"
CNT_EVENT_COUNT = "EVENT_COUNT"

runningOnMaster = None
masterAddress = None
events = None


def masterInit(workgroup):
    global events, runningOnMaster
    events = {-1: None}
    runningOnMaster = True
    workgroup.controls[CNT_EVENT_COUNT] = 0


def workerInit():
    global events, runningOnMaster
    events = {-1: None}
    runningOnMaster = False


class NWEvent:
    """
    Event class that is used to signal events between tasks.
    To wait for an event call it's :py:meth:`wait` method and to signal the event use :py:meth:`set` method.


    :type workgroup: NetWork.workgroup.Workgroup
    :param workgroup: workgroup that will be using this Event

    """

    def __init__(self, workgroup=None):
        self.workgroup = workgroup
        self.workgroup.controls[CNT_EVENT_COUNT] += 1
        self.id = self.workgroup.controls[CNT_EVENT_COUNT]
        events[self.id] = Event()
        self.workgroup.sendRequest(CMD_REGISTER_EVENT,
                                   {
                                       "ID": self.id
                                   })

    def waitOnWorker(self):
        events[self.id].wait()

    def setOnWorker(self):
        sendRequest(CMD_SET_EVENT,
                    {
                        "ID": self.id
                    })

    def waitOnMaster(self):
        return events[self.id].wait()

    def setOnMaster(self):
        self.workgroup.sendRequest(CMD_SET_EVENT,
                                   {
                                       "ID": self.id
                                   })

    def set(self):
        """
        Set the event, any task that called the :py:meth:`wait` method will be waken up
        """
        if runningOnMaster:
            self.setOnMaster()
        else:
            self.setOnWorker()

    def wait(self):
        """
        Sleep until some task calls the :py:meth:`set` method
        """
        if runningOnMaster:
            self.waitOnMaster()
        else:
            self.waitOnWorker()

    def __setstate__(self, state):
        self.id = state["id"]
        self.workgroup = state["workgroup"]

    def __getstate__(self):
        return {"id": self.id, "workgroup": None}


def setEventMaster(request, controls, commqueue):
    #A handler used by Workgroup.dispatcher
    id = request["ID"]
    for worker in controls[CNT_WORKERS]:
        try:
            worker.sendRequest(CMD_SET_EVENT, {"ID": id})
        except DeadWorkerError:
            commqueue.put(Request(CMD_WORKER_DIED,
                                  {"WORKER": worker}))
    events[id].set()


def registerEventMaster(request, controls, commqueue):
    #A handler used by Workgroup.dispatcher
    id = request["ID"]
    for worker in controls[CNT_WORKERS]:
        try:
            worker.sendRequest(CMD_REGISTER_EVENT, {"ID": id})
        except DeadWorkerError:
            commqueue.put(Request(CMD_WORKER_DIED,
                                  {"WORKER": worker}))


def setEventWorker(request):
    events[request["ID"]].set()


def registerEventWorker(request):
    id = request["ID"]
    events[id] = Event()

masterHandlers = {CMD_SET_EVENT: setEventMaster, CMD_REGISTER_EVENT: registerEventMaster}
workerHandlers = {CMD_SET_EVENT: setEventWorker, CMD_REGISTER_EVENT: registerEventWorker}