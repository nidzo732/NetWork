

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Inner workings of the NetWork framework &mdash; NetWork 0.1-alpha documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1-alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="NetWork 0.1-alpha documentation" href="index.html" />
    <link rel="prev" title="NetWork.queue" href="NetWork.queue.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="NetWork.queue.html" title="NetWork.queue"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">NetWork 0.1-alpha documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="inner-workings-of-the-network-framework">
<h1>Inner workings of the NetWork framework<a class="headerlink" href="#inner-workings-of-the-network-framework" title="Permalink to this headline">¶</a></h1>
<p>This document describes how NetWork works internaly. You don&#8217;t need to read this document to use NetWork properly but if you want to know more about NetWork or if you want to help in development the contents of this document could be useful.</p>
<div class="section" id="basic-structure-of-the-network">
<h2>Basic structure of the network<a class="headerlink" href="#basic-structure-of-the-network" title="Permalink to this headline">¶</a></h2>
<p>The workgroup in NetWork is made of one master computer and one or more worker computers.  Workers run a server program that receives instructions from the master. When that server starts it listens on port <strong>32151</strong> and waits for master to register.
When an instance of Workgroup is created the constructor is given a list of IP addresses.</p>
<p>The constructor sends a test code (<tt class="xref py py-const docutils literal"><span class="pre">NetWork.networking.COMCODE_CHECKALIVE</span></tt>) to each of the given IPs and waits for response, when the server program on the worker receives the test code it responds with a return code (<tt class="xref py py-const docutils literal"><span class="pre">NetWork.networking.COMCODE_ISALIVE</span></tt>), if all goes well and the codes are received the worker is added to the workgroup.</p>
<p>Once the workgroup starts working the master computer manages all communication, worker computers can&#8217;t communicate between themselves. All multiprocessing tools send request to the master when used on worker computers.</p>
</div>
<div class="section" id="low-level-networking">
<h2>Low level networking<a class="headerlink" href="#low-level-networking" title="Permalink to this headline">¶</a></h2>
<p>NetWork relies heavily on network communication. Classes used for networking are defined in <tt class="xref py py-mod docutils literal"><span class="pre">NetWork.networking</span></tt>.</p>
<p>When communicating all parts of the framework use the <tt class="xref py py-class docutils literal"><span class="pre">NetWork.networking.NWSocket</span></tt> class, this class is set to the default socket class in NetWork (currently that&#8217;s <tt class="xref py py-class docutils literal"><span class="pre">NetWork.networking.NWSocketTCP</span></tt>).</p>
<p>The default class can be changed to adapt to various types of networks, but all networking classes must implement certain methods and must be self contained, when adapting to another network, no part of NetWork should be changed but the <tt class="xref py py-mod docutils literal"><span class="pre">NetWork.networking</span> <span class="pre">module</span></tt>.</p>
<p>All socket classes must have these methods and members:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">NWSocket:</th><td class="field-body"><dl class="first last docutils">
<dt>listen <span class="classifier-delimiter">:</span> <span class="classifier">method</span></dt>
<dd><p class="first last">Start listening for incoming connections, after call to this method the socket must be ready to accept requests. There is no bind method, binding must be done automaticaly by the class.</p>
</dd>
<dt>accept <span class="classifier-delimiter">:</span> <span class="classifier">method</span></dt>
<dd><p class="first last">Accept a new request, return an instance of a socket class that will be used to receive and respond to that request.</p>
</dd>
<dt>connect(address) <span class="classifier-delimiter">:</span> <span class="classifier">method</span></dt>
<dd><p class="first last">Connect to given address, addres can be any object, anything given to the Workgroup constructor is passed directly to the connect method</p>
</dd>
<dt>send(data) <span class="classifier-delimiter">:</span> <span class="classifier">method</span></dt>
<dd><p class="first last">Send given data to the other side. All data must be handled safely, no buffer overflows, no parital messages. There won&#8217;t be two sends on the same socket. Usually one message is sent, a response is received and the socket is closed.</p>
</dd>
<dt>recv <span class="classifier-delimiter">:</span> <span class="classifier">method</span></dt>
<dd><p class="first last">Receive all data sent from the other side. All data must be handled safely, no buffer overflows, no parital messages. Messages have variable length, it is the responsibility of the socket class to know that length and receive the entire message.</p>
</dd>
<dt>close <span class="classifier-delimiter">:</span> <span class="classifier">method</span></dt>
<dd><p class="first last">Close the socket, it will no longer be used for communication.</p>
</dd>
<dt>address <span class="classifier-delimiter">:</span> <span class="classifier">member</span></dt>
<dd><p class="first last">The address of the remote computer to whitch this socket is connected to, used to identify which worker sent the request.</p>
</dd>
<dt>checkAvailability(address) <span class="classifier-delimiter">:</span> <span class="classifier">static method</span></dt>
<dd><p class="first last">Check if a worker is present at the given address. This method is called on startup when adding workers.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Any class implementing these methods can be used in NetWork, just change the default class to your own</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">NetWork</span><span class="o">.</span><span class="n">networking</span><span class="o">.</span><span class="n">NWSocket</span><span class="o">=</span><span class="n">MySocketClass</span>
</pre></div>
</div>
</div>
<div class="section" id="network-workgroup-workgroup-internals">
<h2><a class="reference internal" href="NetWork.workgroup.html#NetWork.workgroup.Workgroup" title="NetWork.workgroup.Workgroup"><tt class="xref py py-class docutils literal"><span class="pre">NetWork.workgroup.Workgroup</span></tt></a> internals<a class="headerlink" href="#network-workgroup-workgroup-internals" title="Permalink to this headline">¶</a></h2>
<div class="section" id="init">
<h3><tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt><a class="headerlink" href="#init" title="Permalink to this headline">¶</a></h3>
<p>When a new instance is created the constructor goes through the given list of IPs, for each of thos IPs it tries to create an instance of <tt class="xref py py-class docutils literal"><span class="pre">NetWork.worker.Worker</span></tt> class, the worker uses <tt class="xref py py-func docutils literal"><span class="pre">NetWork.networking.NWSocket.checkAvailability()</span></tt> to test if the IP is valid, if all goes well without exception the worker is added to the workgroup.</p>
<p>After the workers are added initialization is done on other modules (<a class="reference internal" href="NetWork.event.html#module-NetWork.event" title="NetWork.event"><tt class="xref py py-mod docutils literal"><span class="pre">NetWork.event</span></tt></a>, <a class="reference internal" href="NetWork.manager.html#module-NetWork.manager" title="NetWork.manager"><tt class="xref py py-mod docutils literal"><span class="pre">NetWork.manager</span></tt></a>...) their internal variables (<tt class="xref py py-data docutils literal"><span class="pre">runningOnMaster</span></tt>, various dictionaries of items etc) are set to their apropriate initial values.</p>
</div>
<div class="section" id="dispatcher-listener-commqueue-and-commands">
<h3>Dispatcher, Listener, <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt> and commands<a class="headerlink" href="#dispatcher-listener-commqueue-and-commands" title="Permalink to this headline">¶</a></h3>
<p>The workgroup has two internal threads (or processes, this can change) that run in the background to receive requests from workers and from the main program that runs on the master computer and uses this Workgroup. These processes don&#8217;t start during <tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt>, they are run manualy using the <tt class="xref py py-meth docutils literal"><span class="pre">startServing()</span></tt> method and are stoped with <tt class="xref py py-meth docutils literal"><span class="pre">stopServing()</span></tt>.</p>
<div class="section" id="networklistener">
<h4>networkListener<a class="headerlink" href="#networklistener" title="Permalink to this headline">¶</a></h4>
<p>Listener has a server socket that listens on port <strong>32151</strong> and accepts requests from the workers, for each new connection it starts a thread that receives the actual request and sends it through the <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt> to the dispatcher process.</p>
</div>
<div class="section" id="dispatcher">
<h4>dispatcher<a class="headerlink" href="#dispatcher" title="Permalink to this headline">¶</a></h4>
<p>Dispatcher is one of the most important part of the workgroup, all IPC and concurrency control tools are handled by dispatcher. The dispatcher receives requests through the <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt>.</p>
<p>Requests begin with a 3 letter code that determines their handler function. The dispatcher looks for handler functions in <tt class="xref py py-data docutils literal"><span class="pre">NetWork.handlers.handlerList</span></tt>, a dictionary that maps the 3 letter codes to their handlers, once the handle function is found the dispatcher runs it and gives it the request.</p>
</div>
<div class="section" id="commqueue">
<h4>commqueue<a class="headerlink" href="#commqueue" title="Permalink to this headline">¶</a></h4>
<p>Commqueue is a queue created during <tt class="xref py py-meth docutils literal"><span class="pre">__init__()</span></tt> and is used to pass commands to the dispatcher. All requests are passed through this queue, when tasks on workers use a tool it sends a message to <tt class="xref py py-attr docutils literal"><span class="pre">networkListener</span></tt> and it passes it via <tt class="xref py py-attr docutils literal"><span class="pre">commqueue</span></tt> to the dispatcher. Tools on the master put their requests directly to this queue.</p>
</div>
<div class="section" id="command">
<h4>Command<a class="headerlink" href="#command" title="Permalink to this headline">¶</a></h4>
<p>Command is a class used to pack requests that are passed to the dispatcher, in addition to the request itself the Command also has additional data:</p>
<blockquote>
<div><ul class="simple">
<li>ID number of the worker who sent the request, if the request was sent from the master the ID is -1</li>
<li>if the request was sent from the worker a socket is also passed to the dispatcher and the handler, this way the handler can respond to the request if needed</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="controlls">
<h3>Controlls<a class="headerlink" href="#controlls" title="Permalink to this headline">¶</a></h3>
<p>Controlls is a manager used internaly in the Workgroup, it contains various properties like list of workers, nubmer of registered queues etc. It is used because dispatcher and listener need to access this shared data.</p>
</div>
</div>
<div class="section" id="communication-with-workers">
<h2>Communication with workers<a class="headerlink" href="#communication-with-workers" title="Permalink to this headline">¶</a></h2>
<p>Each worker in the workgroup is represented with an instance of <tt class="xref py py-class docutils literal"><span class="pre">NetWork.worker.Worker</span></tt> class, these objects are used to control the workers. Workes have methods that are used for controling tasks and using IPC and concurrency control tools, they also have generic <tt class="xref py py-meth docutils literal"><span class="pre">sendMessage()</span></tt> and <tt class="xref py py-meth docutils literal"><span class="pre">sendMessageWithResponse()</span></tt> methods used to pass messages to the workers.</p>
</div>
<div class="section" id="passing-requests">
<h2>Passing requests<a class="headerlink" href="#passing-requests" title="Permalink to this headline">¶</a></h2>
<p>Most of the functionality of NetWork relies on passing requests, over the network and through the <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt> to the dispatcher.</p>
<p>These requests have to be identified and handled by a proper handler function. To identify them 3-letter codes are prepended to each request, the codes are defined in <tt class="xref py py-mod docutils literal"><span class="pre">NetWork.commcodes</span></tt>. Every code has its handler function.</p>
<p>When a request is received (in dispatcher or on the worker server) a dictionary (<tt class="xref py py-data docutils literal"><span class="pre">NetWork.handlers.handlerList</span></tt> for dispatcher, <tt class="xref py py-data docutils literal"><span class="pre">server.handlers</span></tt> on worker) is searched for the appropriate handler function.</p>
</div>
<div class="section" id="worker-server-relations">
<h2>Worker server relations<a class="headerlink" href="#worker-server-relations" title="Permalink to this headline">¶</a></h2>
<p>Each worker runs server.py program. When it starts it creates a server socket and listens for incomming connection, when the master connects and the checks are done it initializes all other module, just like Workgroup.__init__ on the master.</p>
<p>After init it starts receiving requests from the master, just like the dispatcher on the master it also has a dictionary of handler functions linked to their 3-letter codes, when it receives a request it searches that dictionary and passes the request to an apropriate function.</p>
<div class="section" id="task-handling">
<h3>Task handling<a class="headerlink" href="#task-handling" title="Permalink to this headline">¶</a></h3>
<div class="section" id="running">
<h4>Running<a class="headerlink" href="#running" title="Permalink to this headline">¶</a></h4>
<p>When <tt class="xref py py-meth docutils literal"><span class="pre">Workgroup.submit()</span></tt> is called the target function and its arguments are packed in an instance of NetWork.task.Task class. <tt class="xref py py-class docutils literal"><span class="pre">Task</span></tt> is then pickled and sent over the network to the worker. Each task has its own ID, <tt class="xref py py-meth docutils literal"><span class="pre">submit()</span></tt> returns a <a class="reference internal" href="NetWork.task.html#NetWork.task.TaskHandler" title="NetWork.task.TaskHandler"><tt class="xref py py-class docutils literal"><span class="pre">NetWork.task.TaskHandler</span></tt></a> instance that contains that ID and the ID of the worker who&#8217;s running the task.</p>
<p>When a worker receives a request to run a task it creates a new instance of <tt class="xref py py-class docutils literal"><span class="pre">NetWork.workerprocess.WorkerProcess</span></tt> and passes the task to the constructor. <tt class="xref py py-class docutils literal"><span class="pre">WorkerProcess</span></tt> has an internal manager used to save information about running function and it also has methods to control the running task. The <tt class="xref py py-class docutils literal"><span class="pre">Task</span></tt> is then pased to a separate process that unpickles it and runs it, the process also has additional code to detect exceptions and retreive the return value and then put it to the internal manager of the <tt class="xref py py-class docutils literal"><span class="pre">WorkerProcess</span></tt>.</p>
</div>
<div class="section" id="controling-and-getting-information">
<h4>Controling and getting information<a class="headerlink" href="#controling-and-getting-information" title="Permalink to this headline">¶</a></h4>
<p><tt class="xref py py-class docutils literal"><span class="pre">TaskHandler</span></tt> has multiple methods related to the running task, they all use <tt class="xref py py-class docutils literal"><span class="pre">Workgroup</span></tt> methods to pass requests to the <tt class="xref py py-attr docutils literal"><span class="pre">commqueue</span></tt> and then to the worker, the worker receives the request and runs the apropriate method in the <tt class="xref py py-class docutils literal"><span class="pre">WorkerProcess</span></tt>. If the user asks for information, the worker sends it back through the socket and handler passes it through a queue that is automaticaly created by <tt class="xref py py-class docutils literal"><span class="pre">TaskHandler</span> <span class="pre">methods</span></tt>.</p>
</div>
</div>
</div>
<div class="section" id="multiprocessing-tools">
<h2>Multiprocessing tools<a class="headerlink" href="#multiprocessing-tools" title="Permalink to this headline">¶</a></h2>
<p>Despite serving difrent purposes all multiprocessing tools have some common properties.
Each instance of a tool has its own integer ID, every queue, lock, manager or event has its own ID. When requests are sent to the dispatcher an ID is also sent to identify which item is used.</p>
<p>They are all created with <tt class="xref py py-meth docutils literal"><span class="pre">Workgroup.register*()</span></tt> methods - <tt class="xref py py-meth docutils literal"><span class="pre">registerQueue()</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">registerLock()</span></tt>...</p>
<p>Most of them also have local dictionaries containing stuff that is used to handle them localy, for example - for every <tt class="xref py py-class docutils literal"><span class="pre">NWQueue</span></tt> an instance of <a class="reference external" href="http://docs.python.org/library/multiprocessing.html#multiprocessing.Queue" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">multiprocessing.Queue</span></tt></a> is added to <tt class="xref py py-data docutils literal"><span class="pre">NetWork.queue.queues</span></tt> dictionary on every computer in the workgroup, and the position of those queues in the dictionary is determined by the ID of the particular <tt class="xref py py-class docutils literal"><span class="pre">NWQueue</span></tt>.</p>
<div class="section" id="events">
<h3>Events<a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h3>
<div class="section" id="registration">
<h4>Registration<a class="headerlink" href="#registration" title="Permalink to this headline">¶</a></h4>
<p>Events are created with <tt class="xref py py-meth docutils literal"><span class="pre">Workgroup.registerEvent()</span></tt>, when it&#8217;s called a register event command is put on the <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt> and the handler sends a register event message to all workers, along with the message an event ID is passed. On the workers and on the master a new instance of <a class="reference external" href="http://docs.python.org/library/multiprocessing.html#multiprocessing.Event" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">multiprocessing.Event</span></tt></a> is added to <tt class="xref py py-data docutils literal"><span class="pre">NetWork.event.events</span></tt> dictionary.</p>
</div>
<div class="section" id="waiting">
<h4>Waiting<a class="headerlink" href="#waiting" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">NWEvent.wait()</span></tt> method looks the same on both the master and the worker, it simply runs wait method of the apropriate event in :py:data`NetWork.event.events` dictionary.</p>
</div>
<div class="section" id="set">
<h4>Set<a class="headerlink" href="#set" title="Permalink to this headline">¶</a></h4>
<p>Set is different depending on whether it&#8217;s run on master or the worker. On the master it passes set event mesage allong with the ID through the <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt>, on the worker it connects to the listener on the master and send it the message.</p>
<p>In both cases the dispatcher receives the message through the <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt>, it sends set event message to all workers and sets the local event on the  master.</p>
</div>
</div>
<div class="section" id="locks">
<h3>Locks<a class="headerlink" href="#locks" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id1">
<h4>Registration<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Locks are created with <tt class="xref py py-meth docutils literal"><span class="pre">Workgroup.registerLock()</span></tt>, when it&#8217;s called a register lock command is put on the <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt> and the handler sends a register lock message to all workers. On the master a new instance of <tt class="xref py py-class docutils literal"><span class="pre">NetWork.lock.MasterLockHandler</span></tt> is added to :py:class`NetWork.lock.lockHandlers` dictionary. On the master and the workers, a new instance of <a class="reference external" href="http://docs.python.org/library/multiprocessing.html#multiprocessing.Lock" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">multiprocessing.Lock</span></tt></a> is added <tt class="xref py py-data docutils literal"><span class="pre">NetWork.lock.locks</span></tt> dictionary, after that it&#8217;s acquired.</p>
</div>
<div class="section" id="masterlockhandler">
<h4><tt class="xref py py-class docutils literal"><span class="pre">MasterLockHandler</span></tt><a class="headerlink" href="#masterlockhandler" title="Permalink to this headline">¶</a></h4>
<p>A class that is used on the master to hold information about locks, each lock has one. It has a boolean value telling whether the lock is locked and it has a list of waiters that tried to acquire the lock when it was locked.</p>
</div>
<div class="section" id="acquiring">
<h4>Acquiring<a class="headerlink" href="#acquiring" title="Permalink to this headline">¶</a></h4>
<p>When <tt class="xref py py-meth docutils literal"><span class="pre">NWLock.acquire()</span></tt> is called it sends a message to the dispacher (through the network if on worker or through the <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt> if on master) that it wants to acquire the lock, after that it runs the acquire method on the apropriate lock in <tt class="xref py py-data docutils literal"><span class="pre">NetWork.lock.locks</span></tt>.</p>
<p>When dispatcher receives the message it check apropriate <tt class="xref py py-class docutils literal"><span class="pre">MasterLockHandler</span></tt> in <tt class="xref py py-data docutils literal"><span class="pre">NetWork.lock.lockHandlers</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">MasterLockHandler</span></tt> has a boolean value telling whether its locked. If it is not locked, a release lock message is sent to the worker that tried to acquire the lock, when the message is received the appropriate lock in <tt class="xref py py-data docutils literal"><span class="pre">NetWork.lock.locks</span></tt> is released and the process that called acquire on it continues its work.</p>
<p>If the master called acquire and the lock is unlocked then a lock in <tt class="xref py py-data docutils literal"><span class="pre">NetWork.lock.locks</span></tt> on the master is released.</p>
<p>If <tt class="xref py py-class docutils literal"><span class="pre">MasterLockHandler</span></tt> is locked the requester ID is added to the waiting list until the lock is released.</p>
</div>
<div class="section" id="releasing">
<h4>Releasing<a class="headerlink" href="#releasing" title="Permalink to this headline">¶</a></h4>
<p>A message is sent to the dispatcher (network or <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt>) to release the lock. When releasing it checks the waiter list in <tt class="xref py py-class docutils literal"><span class="pre">MasterLockHandler</span></tt>, if there are waiters it gets the ID of the first one, if the ID is -1 (master ID) the local lock on <tt class="xref py py-data docutils literal"><span class="pre">NetWork.lock.locks</span></tt> is released, for other IDs a message is sent to the worker to release the lock, when the worker receives the message it releases the required lock.</p>
</div>
</div>
<div class="section" id="managers">
<h3>Managers<a class="headerlink" href="#managers" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>Registration<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Managers are created with <tt class="xref py py-meth docutils literal"><span class="pre">Workgroup.registerManager()</span></tt>. A message is sent through the <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt> and a new   <tt class="xref py py-class docutils literal"><span class="pre">multiprocessing.manager.dict</span></tt> is added to <tt class="xref py py-data docutils literal"><span class="pre">NetWork.mananager.managers</span></tt> on the master, no registration is performed on the workers.</p>
</div>
<div class="section" id="setting-items">
<h4>Setting items<a class="headerlink" href="#setting-items" title="Permalink to this headline">¶</a></h4>
<p>When <tt class="xref py py-meth docutils literal"><span class="pre">NWManager.setItem()</span></tt> is called a request is sent to the dispatcher (network or <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt>) with the manager ID, item key and the new value, when the dispatcher receives the message it sets that item to a new value on the local manager in <tt class="xref py py-data docutils literal"><span class="pre">NetWork.manager.managers</span></tt></p>
</div>
<div class="section" id="getting-items">
<h4>Getting items<a class="headerlink" href="#getting-items" title="Permalink to this headline">¶</a></h4>
<p>If <tt class="xref py py-meth docutils literal"><span class="pre">NWManager.getItem()</span></tt> is called on the master it simply reads it from <tt class="xref py py-data docutils literal"><span class="pre">NetWork.manager.managers</span></tt>. If it&#8217;s called on the worker it sends the request over the network and the dispatcher responds with the value of that item through the same socket.</p>
</div>
</div>
<div class="section" id="queues">
<h3>Queues<a class="headerlink" href="#queues" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id3">
<h4>Registration<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>Queues are created with <tt class="xref py py-meth docutils literal"><span class="pre">Workgroup.registerQueue()</span></tt>, a message is sent through the <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt>. On the master and the workers a new instance of <a class="reference external" href="http://docs.python.org/library/multiprocessing.html#multiprocessing.Queue" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">multiprocessing.Queue</span></tt></a> is added to <tt class="xref py py-data docutils literal"><span class="pre">NetWork.queue.queues</span></tt> dictionary. On the master a new instance of <tt class="xref py py-data docutils literal"><span class="pre">NetWork.queue.MasterQueue</span></tt> handler is added to <tt class="xref py py-data docutils literal"><span class="pre">NetWork.queue.queueHandlers</span></tt>.</p>
</div>
<div class="section" id="masterqueuehandler">
<h4><tt class="xref py py-class docutils literal"><span class="pre">MasterQueueHandler</span></tt><a class="headerlink" href="#masterqueuehandler" title="Permalink to this headline">¶</a></h4>
<p>A class that is used on the master to hold information about queues, each queue has one. It contains two lists, <tt class="xref py py-attr docutils literal"><span class="pre">items</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">waiters</span></tt>. When an item is put on the queue it&#8217;s added to the items list, when <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> is called the requester is added to the waiters list. <tt class="xref py py-class docutils literal"><span class="pre">MasterQueueHandler</span></tt> has a distribute method that check these lists and if both items and waiters are available it sends the first available item to the first waiter.</p>
</div>
<div class="section" id="id4">
<h4>Getting items<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>The worker (or master) sends a get request allong with the queue ID and calls <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt> on the local queue. The dispatcher receives request, adds the worker to the waiter list and calls <tt class="xref py py-meth docutils literal"><span class="pre">distribute()</span></tt>.</p>
</div>
<div class="section" id="putting-items">
<h4>Putting items<a class="headerlink" href="#putting-items" title="Permalink to this headline">¶</a></h4>
<p>A put item request is sent to dispatcher (network or <tt class="xref py py-data docutils literal"><span class="pre">commqueue</span></tt>), it adds that item to the item list on the appropriate <tt class="xref py py-class docutils literal"><span class="pre">MasterQueueHandler</span></tt>, after adding the item it calls its <tt class="xref py py-meth docutils literal"><span class="pre">distribute()</span></tt> method.</p>
</div>
<div class="section" id="distribution">
<h4>Distribution<a class="headerlink" href="#distribution" title="Permalink to this headline">¶</a></h4>
<p>If the waiters and items list of <tt class="xref py py-class docutils literal"><span class="pre">MasterQueueHandler</span></tt> are not empty it sends the first item from the items list to the first worker on the waiters list, the worker receives the item and puts it to an aprropriate queue in <tt class="xref py py-data docutils literal"><span class="pre">NetWork.queue.queues</span></tt>, it the waiter is master dispatcher just puts the item on a local queue in <tt class="xref py py-data docutils literal"><span class="pre">NetWork.queue.queues</span></tt>.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Inner workings of the NetWork framework</a><ul>
<li><a class="reference internal" href="#basic-structure-of-the-network">Basic structure of the network</a></li>
<li><a class="reference internal" href="#low-level-networking">Low level networking</a></li>
<li><a class="reference internal" href="#network-workgroup-workgroup-internals"><tt class="docutils literal"><span class="pre">NetWork.workgroup.Workgroup</span></tt> internals</a><ul>
<li><a class="reference internal" href="#init"><tt class="docutils literal"><span class="pre">__init__()</span></tt></a></li>
<li><a class="reference internal" href="#dispatcher-listener-commqueue-and-commands">Dispatcher, Listener, <tt class="docutils literal"><span class="pre">commqueue</span></tt> and commands</a><ul>
<li><a class="reference internal" href="#networklistener">networkListener</a></li>
<li><a class="reference internal" href="#dispatcher">dispatcher</a></li>
<li><a class="reference internal" href="#commqueue">commqueue</a></li>
<li><a class="reference internal" href="#command">Command</a></li>
</ul>
</li>
<li><a class="reference internal" href="#controlls">Controlls</a></li>
</ul>
</li>
<li><a class="reference internal" href="#communication-with-workers">Communication with workers</a></li>
<li><a class="reference internal" href="#passing-requests">Passing requests</a></li>
<li><a class="reference internal" href="#worker-server-relations">Worker server relations</a><ul>
<li><a class="reference internal" href="#task-handling">Task handling</a><ul>
<li><a class="reference internal" href="#running">Running</a></li>
<li><a class="reference internal" href="#controling-and-getting-information">Controling and getting information</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#multiprocessing-tools">Multiprocessing tools</a><ul>
<li><a class="reference internal" href="#events">Events</a><ul>
<li><a class="reference internal" href="#registration">Registration</a></li>
<li><a class="reference internal" href="#waiting">Waiting</a></li>
<li><a class="reference internal" href="#set">Set</a></li>
</ul>
</li>
<li><a class="reference internal" href="#locks">Locks</a><ul>
<li><a class="reference internal" href="#id1">Registration</a></li>
<li><a class="reference internal" href="#masterlockhandler"><tt class="docutils literal"><span class="pre">MasterLockHandler</span></tt></a></li>
<li><a class="reference internal" href="#acquiring">Acquiring</a></li>
<li><a class="reference internal" href="#releasing">Releasing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#managers">Managers</a><ul>
<li><a class="reference internal" href="#id2">Registration</a></li>
<li><a class="reference internal" href="#setting-items">Setting items</a></li>
<li><a class="reference internal" href="#getting-items">Getting items</a></li>
</ul>
</li>
<li><a class="reference internal" href="#queues">Queues</a><ul>
<li><a class="reference internal" href="#id3">Registration</a></li>
<li><a class="reference internal" href="#masterqueuehandler"><tt class="docutils literal"><span class="pre">MasterQueueHandler</span></tt></a></li>
<li><a class="reference internal" href="#id4">Getting items</a></li>
<li><a class="reference internal" href="#putting-items">Putting items</a></li>
<li><a class="reference internal" href="#distribution">Distribution</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="NetWork.queue.html"
                        title="previous chapter">NetWork.queue</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/InnerWorkings.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="NetWork.queue.html" title="NetWork.queue"
             >previous</a> |</li>
        <li><a href="index.html">NetWork 0.1-alpha documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Nikola Pavlović.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>